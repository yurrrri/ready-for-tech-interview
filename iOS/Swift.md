# Swift

## 문법

### class와 struct의 차이를 설명하시오.

1. 클래스는 참조 타입이며, 구조체는 값 타입이다.
- 구조체는 스택 영역에 저장되며, 더이상 사용하지 않을 때 메모리에서 자동으로 제거된다.
- 클래스는 힙 영역에 저장되며, ARC 모델에 의해서 메모리가 관리된다.
2. 클래스는 상속이 가능하며, 구조체는 상속이 불가능하다. 
3. 구조체는 멤버와이즈이니셜라이저를 자동으로 제공하며, 클래스는 멤버와이즈 이니셜라이저는 없고 편의생성자와 필수생성자가 존재한다.
4. 구조체는 소멸자가 없으며 클래스는 소멸자가 존재한다.

#### struct와 class와 enum의 차이를 설명하시오.

열거형은 구조체와 같이 값타입이기 때문에 위에서 말씀드린 차이점에도 대부분 해당이 되지만
1. struct/class와 달리 생성자가 없다는 차이점이 있습니다. 열거형 선언시에 case로 같이 정의가 되기 때문입니다.
2. 프로퍼티를 정의할 때 enum은 계산 속성만 정의 가능합니다.

### Struct 가 무엇이고 어떻게 사용하는지 설명하시오.

- 구조체는 프로그래머가 데이터를 용도에 맞게 묶어 표현하고자 할 때 유용하게 사용됩니다.
- 구조체 안에 프로퍼티와 메서드를 선언하여 구조화된 데이터와 기능을 가질 수 있습니다.

### 클래스와 구조체는 각각 어쩔때 사용하는게 좋을까요?

- 정답은 없지만, 클래스는 힙 영역에 할당되기 때문에 필연적으로 느릴 수 밖에 없어서 상속이나 파일 저장, serialize를 통한 전송 이외에는 struct를 사용하는 것이 현명합니다.

### mutating 키워드에 대해 설명하시오.

- struct나 enum의 값 타입에서 자기 자신의 속성을 변경하고자 할 때 메소드 앞에 붙이는 키워드입니다.

#### 왜 class에서는 안붙여도 되고, struct나 enum에서 붙여야하나요?

- struct나 enum같은 값 타입의 경우 자기 자신의 속성을 바꾸게 되면, 기존 인스턴스의 속성의 값을 바꾸는 것이 아닌 값을 바꾼 인스턴스를 복사하여 하나 더 생성하게 됩니다.
- 따라서 매번 속성 변화를 통해서 인스턴스를 복사하게 되면 메모리 관리상 비효율적이므로, mutating 키워드를 붙이면 값을 바꾼 인스턴스로 복사하는 것이 아닌 해당 인스턴스의 값을 변경할 수 있습니다. (이 키워드를 안쓰면 오류가 남 -> 애플에서 강제)

### class의 성능을 향상 시킬수 있는 방법들을 나열해보시오.

- class는 상속이 가능하기 때문에 하위클래스에서 오버라이드 될 가능성이 있어서 Dynamic Dispatch 방식으로 메서드를 호출하게 됩니다. Dynamic Dispatch는 런타임시 마다 일어나기 때문에 성능상 손해를 보게 됩니다.
- 이때 final 키워드를 붙여주게 되면 상속의 가능성을 배제할 수 있기 때문에 Static Dispatch로 함수를 호출하게 되어 컴파일 타임에 함수를 호출하게 되고, 성능은 올라가게 됩니다.
- 또한 private 키워드를 사용할 경우 참조할 수 있는 곳이 현재 파일로 제한 되기 때문에 컴파일 시 다른 클래스에서 오버라이딩하고 있지 않다면, 그때부터 자동으로 static dispatch로 동작하기 때문에 private를 사용함으로써 성능을 향상시킬 수 있습니다.

### init(이니셜라이저)의 종류에 대해 이야기해주세요.

- 지정생성자, 편의 생성자, 필수 생성자, 실패가능 생성자가 있습니다.

#### 지정 이니셜라이저(designated initializer)는 무엇인가요?

- init() 형태를 가지는 생성자로, 모든 저장 속성을 초기화하여 인스턴스가 만들어져 실질적인 데이터의 형태로 메모리에 올라와있는 것으로 만들어주는 생성자를 의미합니다.

#### convenience init(편의 생성자)는 무엇인가요?

- 지정 생성자를 호출하는 생성자로, 지정생성자보다 적은 파라미터로 보다 편리하게 생성하기 위한 생성자입니다.
- 초기화 과정을 좀 더 간편하게 하기 위한 생성자라고 할 수 있습니다.

### instance 메서드와 class 메서드(-> type method)의 차이점을 설명하시오.

- 인스턴스 메서드는 클래스를 통해 인스턴스를 생성해야만 호출할 수 있는 메서드이며, class 메서드는 인스턴스를 생성하지 않고도 타입에서 바로 호출할 수 있는 메소드입니다.

#### class 메서드와 static 메서드의 차이점을 설명하시오.

- class 메서드는 상속 시 재정의가 가능한 메소드이며, static 메소드는 상속 시 재정의가 불가능한 메소드입니다. (모두 상속은 된다는 점에서 주의)

### AnyObject에 대해 설명하시오.

- 어떠한 클래스의 인스턴스도 다 담을 수 있는 타입이며 실제로 사용할 때에는 다운캐스팅을 해야할 필요가 있습니다.

#### Any와 AnyObject의 차이는 뭔가요?

- Any는 어떠한 타입의 인스턴스를 모두 담을 수 있는 타입이고, AnyObject는 어떠한 클래스의 인스턴스도 담을 수 있다 라는 프로토콜입니다. (구조체 XXXX)
- AnyObject는 모든 클래스가 암시적으로 따르는 프로토콜이며, 특정 포로토콜을 클래스 전용 프로토콜로 만들고자 할 때 해당 프로토콜을 AnyObject를 채택하면 됩니다.

### 타입 변환(Type Casting)과 다형성(Polymorphism)에 대해 설명해보세요.

- 하나의 인스턴스가 업캐스팅 타입으로 인식되고 호출된다고 해도, 실제 인스턴스 형태에 따라 재정의된 메소드가 호출되고 실행됨으로써 하나의 인스턴스가 여러 타입의 형태로 표현될 수 있다는 점입니다.

### Swift에서 타입 안전성(type safety)은 어떤 방식으로 보장되나요?

- Swift는 코드를 컴파일 할 때 타입 검사를 진행해서 만약 타입이 불일치하다면 오류를 표시함으로써 안정성을 보장합니다.
- 한번 타입 주석이나 추론을 통해서 정해진 데이터 타입 변수에 다른 타입을 할당하거나, 서로 다른 타입끼리 연산하게 된다면 오류를 발생시킴으로써 개발자가 타입 관련한 실수를 방지할 수 있도록 돕습니다.

### Optional에 대해 설명하시오.

- 옵셔널은 값이 있을 수도 있고, 없을 수도 있음을 나타내는 표현입니다.

#### nil과 null의 차이점을 알고계신가요?

- nil은 옵셔널 타입의 열거형 케이스 중 하나로, 애플에서 값이 없는 값을 접근할 때 에러가 나는 것을 방지 하고자 만든 하나의 키워드입니다. 이 때에는 변수에 접근할 때 프로그램이 꺼지지는 않습니다.
- null은 값이 없음을 의미하여 nil을 벗겨낼 때 이 떄에는 값이 없으므로 접근할 때 에러가 발생하게 됩니다.

#### 옵셔널 값을 추출하는 방법에 대해 설명해주세요.

- 옵셔널을 추출하는 방법에는 강제 추출과 옵셔널 바인딩, 닐 코어레싱이 있습니다.
- 강제 추출은 옵셔널 값의 뒤에 느낌표(!)를 붙여주어 값이 있든 없든 강제로 추출하는 방법입니다. 다만 값이 없을 때 강제로 꺼내오려고 할 경우 런타임 에러가 발생할 수 있기 때문에, 사용을 지양하는 것이 좋습니다.
- 옵셔널 바인딩은 값이 nil 값인지 아닌지 먼저 확인을 한 후에 꺼내오는 방식으로, 주로 if문이나 guard문과 결합하여 값을 확인한 후 꺼내오게 됩니다.
- 닐 코어레싱의 경우 값이 nil이 아니면 해당 값을 꺼내오고, 아니라면 기본값을 할당하는 방식입니다.

#### Optional Chaining과 nil-coalescing operator(??)의 차이점과 사용 시 주의사항은 무엇인가요?

- 옵셔널 체이닝은 옵셔널 데이터타입에 체인 형식으로 접근하면서 하나라도 nil이라면 nil을 반환하는 일련의 과정이고, 닐 코얼레싱 오퍼레이터는 옵셔널의 값을 꺼내올 수 있으면 해당 값을 할당하고, 아니라면 지정한 기본값을 지정하겠다는 문법입니다.
- 옵셔널 체이닝은 반환값이 옵셔널이기 때문에 해당 옵셔널 또한 값을 적절하게 꺼내와야하고, 하나라도 nil이라면 그 뒤의 표현식을 거치지 않고 nil을 반환하므로 nil을 반환하는 경우에 대해 적절하게 대응해야합니다.
- 닐 코얼레싱 오퍼레이터는 옵셔널 값과 동일한 타입이어야한다는 점, 적절한 기본값을 세팅해주어야 한다는 점에서 주의해야합니다.

### Hashable이 무엇이고, Equatable을 왜 상속해야 하는지 설명하시오.

- 해시함수에 input으로 입력될 때 서로 다른 값으로 구분할 수 있는, 즉 해시함수의 input으로 쓰일 수 있는 타입을 "Hashable" 이라고 표현하며, 딕셔너리의 key나 set의 값으로 사용될 수 있는 프로토콜입니다.
- 스위프트의 기본 데이터 타입은 모두 해시함수의 input으로 사용될 수 있기에 Hashable 프로토콜을 채택하고 있습니다.
- Equatable을 상속하는 이유는 hashValue가 항상 unique 하다고 보장할 수 없기 때문입니다.
hashValue가 같아서 해시 충돌이 일어날 가능성이 있기 때문에, hashValue로만은 정확도가 떨어져서 추가로 동일한지 확인하는 Equatable 프로토콜 구현이 필요하게 됩니다.

### 접근 제어자의 종류엔 어떤게 있는지 설명하시오.

접근 제어자에는 **open, public, internal, fileprivate, private** 가 있습니다.

open&public의 경우 **모듈 외부에서 접근이 가능**하다는 공통점이 있지만, **open의 경우 모듈 외부에서 해당 클래스를 상속하는 것이 가능하나** **public은 불가능하다는 차이점이 있습니다.**

internal은 따로 지정하지 않으면 디폴트로 설정되는 기본 접근 레벨로, 해당 모듈 전체에서 사용 가능합니다.

fileprivate은 지정된 요소가 구현된 소스파일 내부에서만 사용 가능합니다.

private는 기능을 정의하고 구현한 범위 내에서만 사용이 가능합니다.

### Generic에 대해 설명하시오.

- 함수, 구조체, 열거형 등에서 한 가지 코드로 모든 데이터 타입에 대응할 수 있는 문법입니다.
- 하는 행위는 완전히 같으나 데이터 타입이 다르다는 이유로 같은 동작을 하는 코드를 여러번 생성할 수 없다는 점에서 코드가 간결해지고, 재사용성을 높일 수 있습니다.

#### generic 함수는 어떻게 정의하나요?

- 함수명 옆에 꺾쇄 안에 타입 파라미터를 넣고, 이 때 대문자로 시작해야한다는 규칙이 있고 보통은 관습적으로 T라고 정의합니다.
- 또한 매개변수의 타입으로 타입 파라미터를 사용하게 됩니다.

#### 제네릭에서 타입 파라미터가 뭔가요?

- 어떤 타입이 입력으로 들어와야 한다는 것을 제시하는 플레이스 홀더 역할을 합니다.

### Subscripts에 대해 설명하시오.

- class, struct, enum 타입 혹은 배열, 딕셔너리, set 등의 collection 타입에서 대괄호를 통해 속성이나 원소를 접근할 수 있는 문법

#### String은 왜 subscript로 접근이 안되는지 설명하시오.

- Swift의 String은 Struct타입이고, characters의 collection이다. 즉 Array<Element>의 element가 Character인 배열이다.
- subscript로 접근이 안되는 이유는 Swift에서 Character는 크기가 가변적인 1개 이상의 Unicode Scalar로 이루어져 있으므로, 데이터가 불일치함이 원인이다.

### Singleton 패턴을 활용하는 경우를 예를 들어 설명하시오.

- 싱글톤 패턴은 객체의 인스턴스가 오직 하나만 생성되어 전체 모듈에서 하나의 인스턴스만 사용하는 패턴입니다. 
- 보통 NotificationCenter나 UserDefaults, UIScreen 등에서 사용하게 됩니다.

### Extension에 대해 설명하시오.

- Extension은 클래스, 구조체, 열거형 타입에 새로운 메소드를 추가하여 사용하는 '수평 확장' 방식입니다.

#### Extension 내부에서 함수 override가 가능한가요?

- Extension 내부에서 함수 override는 불가능합니다.
- Extension 은 기존의 구조체나 클래스, 열거형에 기능을 확장하기 위한 것이지 변형하여 재정의하기 위한 목적이 아니기 때문에 불가능합니다.
- 다만 @objc 키워드를 붙여 objective-C 방식으로 바꾸게 되면 예외적으로 override가 가능합니다.

### 프로토콜이란 무엇인지 설명하시오.

- 특정 역할을 하기 위한 메서드, 프로퍼티, 기타 요구사항 등의 청사진으로 클래스, 구조체, 열거형은 이를 채택함으로써 구체적인 구현부를 구현하게 됩니다.

#### Protocol에서는 왜 var만 되나요?

- 프로토콜은 구현의 최소 요구사항만 명시해두는 것인데, 만약 let으로 선언하게 되면 이를 구현하는 인스턴스는 구현할 수 있는 범위가 제약적일 수 밖에 없어서 var로 선언합니다.

### Protocol Oriented Programming과 Object Oriented Programming의 차이점을 설명하시오.

- OOP는 객체 중심 프로그래밍으로, 클래스의 상속이 중심이 되는 프로그래밍입니다. 클래스는 다중 상속이 불가능하며, 상위 클래스의 메모리 구조를 따라갈 수 밖에 없기때문에 필요하지 않는 속성이나 메소드도 상속된다는 단점이 있습니다. 또한 Swift에서는 클래스만 상속 가능합니다.
- 프로토콜 프로그래밍에서는 여러 프로토콜의 채택이 가능하며, 클래스 뿐만 아니라 값 타입의 모든 객체에서 프로토콜 채택이 가능합니다. 또한 상속이 아니기 때문에 필요한 속성이나 메소드만 채택하여 구현할 수 있다는 장점이 있습니다.

### Copy On Write는 어떤 방식으로 동작하는지 설명하시오.

https://babbab2.tistory.com/18

- Copy-On-Write는 원본이나 복사본이 수정되기 전까지는 복사하지 않고 메모리 값을 공유해서 사용하다가, 수정이 시작될 때 값을 복사하는 작업으로 Swift에서는 문자열이나 컬렉션 타입에서 Copy-on-Write 로 동작하게 됩니다.
- 컬렉션 타입은 모두 struct로, 값 타입이기때문에 본래 값 자체를 복사하여 할당해야하지만 원본의 메모리 주소값을 가지고 있다가 수정이 일어나는 경우에 값을 복사힘으로써 메모리를 효율적으로 관리할 수 있게 됩니다.

### Result타입에 대해 설명하시오.

- 에러가 발생하는 경우, 에러를 외부로 던지고 do-catch문으로 처리하는 것이 아니라
- 리턴 타입을 Result 타입으로 구현하여 성공했을 때와 실패했을 때의 정보를 열거형의 연관값으로 함께 담아서 리턴함으로써 해당 정보를 통해 에러처리를 할 수 있는 타입입니다.

#### 기존 에러 처리 방식인 throws와 do-catch에 비해서 Result 타입이 얻는 이점이 뭐가 있을까요?

1) 에러를 던지는 함수에서 에러 형식을 특정하기 어려움 (어떤 에러인지 알려면 추가적으로 시간이 소요됨)
2) 에러가 발생할 때 throw를 할 필요가 없어짐
3) catch문에서 switch 문으로 에러를 처리할 때, 에러 타입캐스팅 불필요

### Codable에 대하여 설명하시오.

- Encodable과 Decodable로 나뉘는 데이터 타입으로, 사용자가 정의한 데이터 타입을 다른 형식으로 쉽게 인코딩하고 디코딩하기 위해 사용하는 프로토콜입니다.
- 앱을 만들기 위해서는 JSON으로 서버와 데이터를 주고받는 경우가 많은데, 이 때 Json Data로 변환을 한다거나 Json Data를 특정 타입의 인스턴스로 디코딩할 때 많이 사용합니다.

#### 그럼 특정 인스턴스를 어떻게 Json 데이터로 만들고, Json 데이터를 어떻게 디코딩할 수 있을까요?

- 보통 Json 문자열의 형식대로 구조체를 만들어서, 해당 구조체를 따르는 인스턴스를 Foundation 프레임워크에 내장되어있는 JSONEncoder로 인코딩을 해서 해당 데이터를 서버로 보내게 됩니다.

- 서버 response로 오는 JsonData는 해당 형식의 구조체 형식으로 디코딩하여 구조체 인스턴스의 데이터를 다룰 수 있게 됩니다.

### ❗️property wrapper에 대해서 설명하시오.


### some 키워드에 대해 설명하시오.

https://velog.io/@haze5959/Swift-some-%ED%82%A4%EC%9B%8C%EB%93%9C-%EC%96%B8%EC%A0%9C-%EC%93%B0%EB%A9%B4-%EC%A2%8B%EC%9D%84%EA%B9%8C
- 함수 내부의 코드에 따라 리턴 타입이 바뀔 수 있도록 불투명한 타입?으로 정의하고자 하는 키워드

### Closure에 대하여 설명하시오.

- 이름이 없는 함수, 즉 특정 기능을 하는 코드를 하나의 블록으로 모아놓은 것을 의미하며 함수와 같이 일급객체 취급을 하기 때문에 타입으로 사용할 수도 있습니다.
- 또한, 일반 함수와는 달리 변수에 저장되어 메모리의 힙 영역에 저장될 수 있는 함수를 클로저라고 하기도 합니다.

#### Closure와 함수와의 관계에 대해 설명하시오.

- 함수는 클로저의 일종이라고 할 수 있습니다. 즉, 클로저와 함수는 기능이 완전히 동일하나 형태만 다르고, 함수가 클로저에 속한 개념입니다.
- 클로저에는 3가지 형태가 있습니다.
- 이름이 있고 어떤 값도 캡쳐하지 않는 클로저 -> 전역 함수
이름이 있고 관련한 함수로 부터 값을 캡쳐 할 수 있는 클로저 -> 중첩 함수
경량화 된 문법으로 쓰여지고 관련된 문맥(context)으로부터 값을 캡쳐할 수 있는 이름이 없는 클로저 -> 클로저 표현

#### 탈출 Closure에 대해 설명하시오.

- 클로저의 실행이 해당 클로저를 사용하고 있던 함수를 벗어나서도 실행할 수 있는 클로저를 의미합니다. 즉, 함수의 실행을 벗어나서도 사용이 필요한 클로저를 앞에 @escaping 키워드를 붙여서 사용하는 클로저를 탈출 클로저라고 합니다.
- 보통 내부 클로저를 외부 변수에 저장하거나, 비동기 프로그래밍할 때 유용하게 사용됩니다.

### KVO 동작 방식에 대해 설명하시오.

- KVO는 Key-Value-Observing 방식의 줄임말로써, 특정 키에 해당하는 value 값을 관찰하고 있다가 이 value에 변화가 감지가 되면 특정 코드가 실행되는 방식으로 동작하는 것을 의미합니다.
- 보통 앱의 각 요소끼리 (모델과 뷰와 같은) 소통하기에 적합하며, NSObject를 상속한 클래스에서만 KVO를 사용할 수 있습니다.

### defer란 무엇인지 설명하시오.

- defer가 호출된 스코프 내에서 작업의 실행을 가장 마지막으로 미루는 개념

#### defer가 호출되는 순서는 어떻게 되고, defer가 호출되지 않는 경우를 설명하시오.

- 한 함수 내에서 defer가 여러번 호출되었을 경우에, 가장 마지막에 실행된 defer문부터 역순으로 실행됩니다.
- defer는 한번 실행이 되면 나중에 실행한다고 예약을 하는 것이기 때문에, defer문이 호출되기 전에 함수가 return문을 통해 종료될 경우에는 호출되지 않습니다.

### 최근 가장 인상깊은 Swift의 동향이나 신기술이 있는지?

<br/>

## ARC

### ARC란 무엇인지 설명하시오.

- Swift에서 클래스와 클로저같은 참조타입의 메모리를 reference count의 증가/감소를 기반으로 해제 시점을 자동으로 관리해주는 시스템

#### ARC를 컴파일단에서 관여하나요, 런타임단에서 관여하나요?

- 컴파일단에서 컴파일러가 이미 인스턴스들의 해제 시점과 참조 횟수를 인지하고 있어, reference count가 0이 되는 시점에 자동으로 해제를 진행하게 됩니다.

### Retain Count(=reference count) 방식에 대해 설명하시오.

- 어떠한 변수가 참조 타입의 데이터를 가리키게 되면 참조 횟수가 올라가게 되고, ARC에서는 RC가 0이 되면서 더이상 참조하고 있는 변수가 없을 때 힙에서 메모리를 제거해주게 됩니다.

#### Strong 과 Weak 참조 방식에 대해 설명하시오.

- Strong은 참조 타입을 가리킬 때 reference count를 증가시키지만 weak은 참조 타입을 가리킬 때 증가시키지 않도록 하는 방식입니다.

#### unowned와 weak의 차이?

- weak의 경우 가리키는 인스턴스가 메모리에서 해제되면 자동으로 nil을 할당해주지만, unowned는 자동으로 nil을 할당해주지 않아서 소유하고 있는 인스턴스가 메모리에서 해제된 상태에서 접근하고자 할 경우 에러가 발생할 수 있습니다.
- 따라서 weak는 보통 소유자에 비해 짧은 생명주기를 가진 인스턴스를 참조할 때 사용하며, unowned는 소유자에 비해 생명주기가 더 긴 인스턴스라는 것이 보장될 때 사용합니다.

### 순환 참조에 대하여 설명하시오.

- 참조 타입의 인스턴스가 서로가 서로를 참조할 때 순환 참조가 발생한다고 하며, 각자가 메모리에서 해제되었음에도 참조하고 있는 변수에는 메모리가 살아있어서 불필요한 메모리가 살아있는 메모리 누수 현상이 발생하는 경우를 의미합니다.

#### 순환 참조는 왜 발생하나요?

- 클래스안의 프로퍼티가 서로를 가리키면 각 인스턴스를 만들때 Reference count가 2씩 증가하게 됩니다. 이때 인스턴스가 해제될 때에는 서로 가리키고 있는 인스턴스가 해제된 상황이 아니므로 참조 횟수가 0이 아니기 때문에 인스턴스는 메모리가 해제된 상황이나 실질적으로는 메모리에 껍데기 데이터가 남아있게 됩니다.
- 추가적으로 클래스가 프로퍼티로 클로저를 가지고 있을 때, 클로저 또한 참조 타입이므로 인스턴스를 만들어서 클로저를 실행할 때, 서로를 가리키게 되는 현상이 발생합니다.

#### 순환 참조를 방지하기 위한 방법을 설명해주세요.

- 약한 참조나 비소유 참조를 통해서 가리킬때 Reference count가 증가하지 않도록 조치합니다.

### Retain cycle과 escaping 클로저와의 관계는?

https://swifty-cody.tistory.com/11
https://noah0316.github.io/Swift/2022-04-08-[weak-self]-%EB%AC%B4%EC%A1%B0%EA%B1%B4-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94%EA%B2%8C-%EB%A7%9E%EB%8A%94%EA%B1%B8%EA%B9%8C/

- escaping 클로저는 함수가 끝남에도 오랫동안 남아있는 클로저를 의미하는데, 즉 오래 남아있어야하기 때문에 힙 영역에 메모리가 할당됩니다.
- 이떄 이스케이핑 클로저가 클래스의 멤버로서 존재하고, 클로저에서 인스턴스 자기 자신(self)를 가리키게 되면 강한 참조 사이클이 발생하게 됩니다.

### 클로저에서 내부의 순환참조를 방지하려면 어떻게해야하나요?

- [weak 혹은 unowned self]를 붙임으로써 약하게 참조하도록 합니다.

### ARC, MRC 차이점

- ARC는 컴파일러가 컴파일 시점에 자동으로 retain/release 를 실행해주는 자동 메모리 관리 시스템이고
- MRC는 개발자가 직접 retain/release를 통해 메모리 관리를 해주는 시스템


<br/>

## Functional Programming

### 순수함수란 무엇인지 설명하시오.

- 동일한 인자가 전달되면 항상 동일한 결과를 반환하는 함수를 순수함수 라고 합니다.

### 함수형 프로그래밍이 무엇인지 설명하시오.

- 데이터 처리를 수학적 함수를 선언을 통한 함수 계산으로 처리하는 프로그래밍으로서, 함수를 일급 객체로 취급한다는 특징이 있습니다.
- 개발자는 중간 과정을 신경쓰지 않고, 정의된 함수를 선언하여 "어떻게 조합해서 결과를 만들어낼까"만 신경쓰면 되므로, 코드가 간결해진다는 장점이 있습니다.

### 고차 함수가 무엇인지 설명하시오.

- 함수의 input이 함수이거나, output이 함수인 함수를 고차함수라고 합니다.

### Swift Standard Library의 map, filter, reduce, compactMap, flatMap에 대하여 설명하시오.

- map은 컬렉션의 아이템을 매핑해서 변형된 새로운 배열을 리턴하는 함수입니다.
- filter는 컬렉션의 아이템을 조건에 의해 true를 만족하는 아이템만 조합하여 새로운 비열을 리턴하는 함수입니다.
- reduce는 초기값을 가지고 아이템을 결합하여 하나의 값으로 리턴하는 함수입니다.
- compactMap은 각 아이템을 매핑해서 변환하되, 옵셔널을 제거한 배열을 리턴해주는 함수입니다.
- flatMap은 각 아이템을 매핑하여 변환하되, 내부의 중첩된 배열을 제거하고 리턴합니다. 예를들어 2차원 배열을 인풋으로 주었을 때 1차원 배열을 return해줍니다.

#### map, compactMap, flatMap 차이

https://www.hackingwithswift.com/articles/205/whats-the-difference-between-map-flatmap-and-compactmap
- 셋 다 컬렉션의 아이템을 매핑해서 변형된 새로운 컬렉션을 반환한다는 특징이 있는데, compactMap은 map과는 달리 nil값을 제거한 컬렉션을 반환한다는 차이점이 있고
- flatMap도 마찬가지로 nil을 반환하지만, 2차원 이상의 배열을 1차원 배열로 반환한다는 차이점이 있음

<br/>
