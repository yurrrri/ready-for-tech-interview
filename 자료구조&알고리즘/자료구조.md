## 자료구조

- **Q. Array는 어떤 자료구조 인가요?**
    
    Array는 데이터를 메모리 상에서 연속적으로, 순차적으로 미리 할당된 크기만큼 저장하는 자료구조입니다.
    
- **Q. Dynamic Array는 어떤 자료구조 인가요?**
    
    기존의 Array는 미리 할당된 크기 만큼의 데이터만 저장할 수 있어서, 해당 사이즈보다 더 많은 데이터를 저장하지 못합니다. Dynamic array는 이 한계를 보완하기 위해, array의 size를 resize를 하여 유동적으로 데이터를 저장할 수 있는 자료구조입니다.
    
- **Q. Linked List에 대해서 설명해 주세요.**
    
    linked list는 노드라는 구조체로 이루어져있는데, 노드는 데이터와 그 다음 노드를 가리키는 address 값으로 구성되어있습니다. 물리적인 메모리상에서는 비연속적으로 저장되어있지만, address값이 그 다음 node를 가리키게 되어있기 때문에 논리적으로 연속성을 가진 자료구조입니다.
    
- **Q. Dynamic Array를 Linked list와 비교하여 장단점을 설명해 주세요.**
    
    linked list와 비교하여 dynamic array의 장점은,
    
    - 데이터의 접근과 맨 끝에 데이터를 추가/삭제할 때 시간복잡도가 O(1)이기 때문에 빠르다는 장점이 있습니다,
    
    이에 비해 단점으로는,
    
    - 맨 끝이 아닌 곳에 데이터를 삽입/삭제할 때 시간복잡도가 O(n)이기 때문에 느리다는 단점이 있습니다. Dynamic array도 마찬가지로 array이기 때문에, 데이터가 순차적으로 저장되어야하기 때문에 뒤에 있는 데이터들을 일일이 한칸씩 shift를 해야하기 때문입니다.
    - resize시에 데이터를 일일이 옮기는 작업으로 인해 시간복잡도가 O(n)이 소요되기 때문에 성능이 낮아지는 단점이 있습니다.
    - resize시에 시간이 많이 걸린다는 단점 때문에, size를 필요한 것 이상으로 넉넉하게 할당할 때 사용하지 않는 메모리 공간이 있을 수 있으므로 이 때 메모리 효율이 좋지 않습니다.
- **Q. ⭐ Array vs Linked list를 비교해서 설명해주세요**
    
    Array는 메모리 상에서 연속적으로 데이터를 저장하는 자료구조이며, linked list는 물리적 메모리상에서는 비연속적이나 각 노드가 그 다음 노드에 대한 주소값을 가지고 있기 때문에 논리적으로는 연속성을 가지는 자료구조입니다.
    
    시간복잡도에 관해 비교해서 설명해드리자면, 데이터 조회는 array는 O(1), linked list는 O(n), 삽입/삭제는 Array는 O(n), linked list는 O(1) 입니다.
    
    따라서 데이터의 크기를 미리 알고있고, 조회할 일이 잦다면 array를 사용하고, 데이터의 크기가 불확실하고 삽입이나 삭제가 잦다면 linked list를 사용하는 것이 유리합니다.
    
- **Q. 어느 상황에 Linked list를 쓰는게 Array보다 더 나을까요?**
    
     linked list의 경우 데이터 삽입/삭제가 잦을 때 시간복잡도가 O(1) 이므로 유리합니다.
    
    또한 데이터의 크기를 미리 알 수 없을 때 유리합니다.
    
    데이터 조회를 할일이 별로 없을 때에도 유리합니다. 
    
- **Q. 어느 상황에 Array를 쓰는게 Linked list보다 더 나을까요?**
    
    array의 경우 데이터 조회가 잦을 경우 시간 복잡도가 O(1)이므로 더 유리합니다.
    
    데이터의 크기를 미리 알 수 있을 때에는 array를 사용하는게 더 유리합니다. linked list는 각 노드마다 값 뿐만 아니라 다음 노드를 가리키는 주소도 같이 메모리에 저장하고 있기 때문에 메모리를 더 많이 차지하는 단점이 있기 때문입니다.
    
- **Q. Array와 Linked List의 memory allocation은 언제 일어나며, 메모리의 어느 영역을 할당 받나요?**
    
    array는 컴파일 단계에서 메모리 할당이 일어나며, 스택 메모리 영역에 할당됩니다.
    
    linked list는 런타임 단계에서 새로운 노드가 추가될 때마다 메모리 할당이 일어나며, 힙 메모리 영역에 할당됩니다.
    
- **Q. Queue는 무슨 자료구조 인가요?**
    
    First-In-First-Out의 자료구조입니다. 데이터를 추가하는 enqueue 연산, 데이터를 삭제하는 dequeue 연산이 있는데 2가지 연산 모두 시간복잡도는 O(1)입니다.
    
    활용 예시로는 캐쉬 구현, 프로세스 관리, 너비우선탐색 등이 있습니다.
    
- **Q. Array-Base 와 List-Base의 경우 어떤 차이가 있나요?**
    
    array-base는 array로 큐를 구현하는 방식입니다. 다만 enqueue와 dequeue 하는 과정에서 남는 메모리가 발생하므로, 메모리 비효율을 개선하기 위해 circular queue로 구현하게 됩니다. 또한 enqueue가 발생하면서 size의 크기보다 더 많은 데이터를 enqueue할 경우, resize를 하게됩니다. 다만 resize는 간헐적으로 발생하게 되었을 때 이를 O(1)이 나눠가지면서, 실질적으로 enqueue의 시간복잡도는 O(1)을 유지하게 됩니다.
    
    list-base는 연결 리스트로 큐를 구현하는 방식입니다. 따라서 enqueue/dequeue의 시간복잡도는 O(1)입니다.
    
    요약하자면, 두 가지 자료구조로 구현하는 큐는 모두 삽입/삭제 시간복잡도가 O(1)입니다. 또한 성능 자체는 array-base가 더 좋으나 resize가 자주 발생하는 최악의 경우에는 시간복잡도가 O(n)이라는 단점이 있습니다. 또한 list-base로 큐를 구현하는 경우 enqueue 할 때마다 메모리 할당을 하므로 메모리 할당이 잦으면 전반적인 런타임이 느릴 수 있습니다.
    
- **Q. Stack은 어떤 자료구조 인가요?**
    
    스택은 Last-In-First-Out 구조의 자료구조입니다. pop연산과 push 연산 모두 시간복잡도가 O(1)이며, 활용 예시로는 괄호 유효성 검사, 후위 표기법 연산, 깊이 우선 탐색 등이 있습니다.
    
- **Q. ⭐ Queue vs priority queue를 비교하여 설명해 주세요**
    
    queue는 First-In-First-Out, 선입 선출의 자료구조로 가장 먼저 들어간 데이터 순으로 빠져나오게 됩니다. 반면 priority queue는 순서와 상관없이 우선순위가 높은 순서대로 데이터가 빠져나오는 자료구조입니다.
    
    queue의 enqueue/dequeue의 시간복잡도는 모두 O(1)이며 priority queue의 push/pop 연산 모두 O(logn)입니다.
    
- **Q. ⭐⭐BST(Binary Search Tree)는 어떤 자료구조 인가요?**
    
    이진탐색트리는, 어떠한 노드를 선택하더라도 해당 노드의 왼쪽 서브 트리는 그 노드보다 작은 값들로만 구성되어있고, 오른쪽 서브 트리는 그 노드보다 큰 값들로만 구성되어있는 정렬된 이진 트리를 의미합니다.
    
    검색, 추가, 삭제 모두 시간복잡도는 **O(logn)**입니다.
    
- **Q. BST의 worst case 시간복잡도는  $O(n)$입니다. 어떠한 경우에 worst case가 발생하나요?**
    
    이진 탐색 트리가 한쪽으로만 치우쳐져있을 때 linked list와 거의 동일하게 되어버려 시간복잡도가 O(n)이 됩니다.
    
- **Q. BST worst case를 해결하는 방법은 무엇인가요**
    
    이진 트리의 균형이 잘 맞도록 높이가 가능한한 낮게 유지하도록 조정합니다. 트리의 균형이 잘 맞도록 유지하는 이진 트리로 대표적으로는 AVL 트리와 Red-black Tree가 있습니다. 
    
- **Q. 이진 탐색 트리에서 저장된 정보가 128개일 때 탐색횟수는 몇 번 째일까요?**
    
    이진 탐색트리의 검색 시간복잡도가 O(logn)이므로 7번째입니다.
    
- **Q. ⭐⭐ Hash table는 어떤 자료구조 인가요?**
    
    해쉬 테이블은 빠른 탐색을 위한 자료구조로써, key-value 쌍의 데이터를 입력받습니다.
    
    해쉬 함수에 key값을 입력으로 넣어 나온 해쉬값을 위치를 지정하여 key-value 데이터 쌍을 저장합니다.
    
    저장, 삭제, 검색의 시간복잡도는 모두 O(1)입니다.
    
- **Q. 좋은 hash function의 조건은 뭘까요?**
    
    보편적인 기준으로 연산 속도가 빠르고, 해시값이 최대한 겹치지 않고 고르게 분포될 수 있도록 하는 함수가 좋은 hash function입니다.
    
- **Q. ⭐⭐⭐⭐ Hash table에서 collision이 발생하면 어떻게 되나요? 해결방법엔 뭐가 있을까요?**
    
    collision이 발생할 경우, 대표적으로 2가지 방법으로 해결합니다.
    
    첫번째, open addressing 방식은 미리 정한 규칙에 따라 hash table에 비어있는 슬롯을 찾는 방식으로, 대표적으로 선형 조사법과 이차 조사법, 이중해싱이 있습니다.
    
    선형 조사법은 충돌이 발생한 해시값으로부터 일정한 값을 건너뛰면서 빈 슬롯을 찾아 데이터를 저장하는 것이고, 이차 조사법은 충돌이 발생한 해시값으로부터 일정한 값의 제곱수를 건너뛰면서 빈 슬롯을 찾아 데이터를 저장하는 방식입니다.
    
    이중 해싱은 2개의 해시함수를 사용하게 되는데, 하나의 해시함수에는 해시값을 얻을때 사용하고 또 하나의 해시함수는 collision이 발생할 경우 해시값의 이동폭을 얻기 위해 사용합니다.
    
    두번째로 separate chaining 방식이 있습니다. linked list를 사용하여 hash table을 구현하는 것이고, 만약에 collision이 발생한다면 같은 해시값을 가지는 위치에 linked list에 노드를 추가하여 데이터를 저장합니다.
    
- **Q. 이중해싱(double hashing)이 무엇인지 설명해 주세요.**
    
    이중 해싱은 2개의 해시함수를 사용하게 되는데, 하나의 해시함수에는 해시값을 얻을때 사용하고 또 하나의 해시함수는 collision이 발생할 경우 해시값의 이동폭을 얻기 위해 사용합니다. 따라서 collision이 발생할 경우에 해당 함수를 활용하여 얻은 이동폭으로 건너뛰어 빈 슬롯을 찾아 해당 슬롯에 저장하게 됩니다.
    
- **Q. 이중해싱의 장점과 단점에 대해서 설명하고, 단점을 어떻게 해결할 수 있을지 설명해 주세요.**
    
    이중해싱의 장점은 클러스터링의 문제가 적다는 것이며, 단점은 해싱을 2번 거치기 때문에 연산량이 많고 효율이 좋지 않다는 단점이 있습니다.

- **Q. ⭐ Hash table에서 worst case에 시간복잡도는 $O(n)$일 수 있는데, 어떤 상황인가요?**
    
    open addressing 방식에서는 미리 정한 방식으로 빈 슬롯을 찾기 위해 건너뛰는 과정에서, 최악의 경우 n번을 건너뛸 수 있으므로 이때는 최악의 시간복잡도가 O(n)입니다.
    
    또한 separate chaining 방식에서는 최악의 경우에 모든 key값의 해쉬값이 똑같을 때, 특정 key에 n개의 노드가 연결되어있는 연결리스트가 되므로 검색에 소요되는 시간이 O(n)이 됩니다.


- **Q. 시간복잡도가 뭔가요?**

    특정한 크기의 입력에 대하여 알고리즘이 얼마나 오래걸리는지를 의미하는 척도입니다.
    시간복잡도의 표기법은 빅오 표기법, 오메가 표기법, 세타 표기법이 있습니다.

- **Q. big O vs. big seta vs. big omega를 비교해서 설명해 주세요.**
    
    빅오표기법은 알고리즘의 최악의 실행시간을 표기하는 방법이고,
    
    빅 세타 표기법은 알고리즘의 평균의 실행시간, 오메가 표기법은 최상의 실행시간을 표기하는 방법입니다.
    
- **Q. 다른 것을 사용하지 않고, Big-O를 사용하는 이유가 있을까요?**
    
    최악의 경우로 시간 복잡도를 표기해야만 오차가 없기때문입니다. 예를 들어 이 알고리즘에는 0.3초 정도 시간이 소요될 것이라고 예상을 했으나 1초가 걸리게 된다면 이슈가 있을 수 있으므로, 최악의 경우를 가정하고 알고리즘을 설계해야 하기에 빅오 표기법을 사용하게 됩니다.
    
- **Q. O(1)은 O(N^2) 보다 무조건적으로 빠른가요?**
    
    !https://github-production-user-asset-6210df.s3.amazonaws.com/37764504/240923232-1b0661b0-7162-40c6-814c-9cf9d266cc22.png
    
    그렇지 않습니다. O(1)은 입력 개수와 무관하게 항상 상수의 시간이 든다는 의미이므로 드물게 O(n^2)가 더 빠른 경우가 존재합니다.

- **Q. Red-Black Tree 구조를 설명해 주세요.**


- **Q. AVL 구조 설명해주세요.**


- **Q.  Quick sort vs merge sort비교 하시오**
    
    Quick Sort와 Merget Sort 모두 분할-정복 방식으로 정렬하는 방식이며, 시간복잡도는 모두 O(nlong)입니다.
    
    차이점으로는 quick sort는 특정 원소를 pivot으로 정하여, 왼쪽에서부터 pivot보다 큰 데이터와 오른쪽에서부터 pivot보다 작은 데이터를 찾아 서로 바꿔가고, 엇갈린 순간에는 pivot을 가운데에 두어 왼쪽과 오른쪽을 분할한 후 또 분할된 리스트에 대해 정렬을 진행하여 이를 합치는 것을 반복하여 정렬을 진행합니다. quick Sort는 배열이 이미 정렬되었을 경우에는 시간복잡도가 O(n^2)이므로 불안정한 정렬방식입니다.
    
    merge sort는 배열이 더이상 분해되지 않을 때까지 분할을 먼저 진행을 한 다음에, 분할된 배열끼리 비교하여 작은 순서대로 배열에 데이터를 추가하여 합치는 과정을 반복하게 됩니다. merge sort는 quick sort와는 달리 안정적인 정렬 방식입니다.


- **Q. ⭐ 가장 빠른 정렬 알고리즘은 무엇인가요?**
    
    가장 빠른 정렬 알고리즘은 Quick Sort 알고리즘입니다. 특정 원소를 pivot으로 하여 해당 pivot 앞에는 작은 원소가 오도록, 뒤에는 큰 원소가 오도록 분할한 다음 합치는 방식을 반복하여 전체가 정렬되게 하는 방법으로, 시간복잡도가 O(nlogn)으로 다른 정렬 알고리즘에 비해 빠른 시간복잡도를 가지고 있습니다.
  
    
- **Q. Quick sort가 이름대로 가장 빠른가요?**
    
    항상 가장 빠른 정렬 알고리즘이라고 보기 어렵습니다. 평균적으로는 시간복잡도가 O(logn)이지만 데이터가 이미 정렬되어있는 경우에는 최악의 경우 시간복잡도가 O(n^2)이기때문입니다.
    
- **Q. 정렬이 되어 있는 상태에서는 어떤 정렬이 가장 빠를까요?**
    
    삽입 정렬이 가장 빠릅니다. 삽입 정렬은 각 원소마다 앞 원소들에서 자기가 들어갈 위치를 찾고, 교환할 필요가 있을 경우에만 교환하기 때문에 빠르게 작동합니다.
