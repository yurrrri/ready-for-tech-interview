## 네트워크

### OSI 7계층과 TCP/IP 4계층을 비교하여 설명해주세요.

   <img width="500" src="https://github.com/yurrrri/ready-for-tech-interview/assets/37764504/0a4596a4-9c76-4020-a820-f866b4f00dc2" />
   
 - 응용 계층 : 응용프로그램을 통해 해당 프로토콜을 용이하게 사용할 수 있도록 하는 계층 → **사용자와 가장 가까움**
 - 표현 계층 : 응용 계층으로부터 받은 데이터를 읽을 수 있는 형식(인코딩, 디코딩, 암호화, 복호화를 통한)으로 변환해주는 계층
 - 세션 계층 : **통신 장치간의 연결설정**과 데이터 송/수신 제어하며, **통신 방식을 결정해주는 계층**
 - 전송 계층 : 하위계층으로 신뢰할 수 있는 데이터 전송, 전달 데이터 오류 제어
 - **네트워크 계층 : IP 주소(경로)를 제공하는 역할 수행**
 - 링크 계층 : 물리 계층을 통해 송수신되는 정보의 **오류를 제어**하고, 물리적인 장치를 식별하는 데 사용하는 주소인 **MAC 주소를 기반으로 통신**한다.
 - 물리 계층 : 데이터가 전송되는 물리적인 전송 기술이며, 비트의 통신단위로 통신 (케이블, 허브)
    
 OSI 7계층은 네트워크 통신을 계층별로 나누어 표준화한 모델이며, 실무적으로 쓸 때는 복잡한 탓에 이를 단순화한 TCP/IP 4계층이 많이 사용되고 있습니다. <br/>
 OSI 7계층은 물리계층-링크계층-네트워크 계층-전송 계층-세션 계층-표현 계층-응용 계층으로 이루어져있으며 TCP/IP 4계층은 OSI 7계층의 물리-링크계층을 묶은 네트워크 인터페이스 계층, 인터넷 계층, 전송 계층, OSI 7계층의 세션-표현-응용 계층을 묶은 응용 계층으로 단순화되어 구성되어 있습니다.
 
#### 네트워크 통신 과정을 계층 모델로 나누는 이유는 무엇일까요?
#### TCP/IP 모델과 OSI 모델의 차이점은 무엇인가요?
#### 실제 인터넷 통신은 어떤 모델을 더 가깝게 따르나요?
    
### ⭐ TCP vs UDP를 비교해서 설명해주세요
    
- **TCP는 연결형, 신뢰성 프로토콜**입니다. 데이터를 전송하기 전에 3-way handshake를 통해 두 호스트 전송 계층 사이에 논리적 연결을 설립하고, 신뢰성있는 연결을 위해 오류제어, 흐름제어, 혼잡제어 등을 실행합니다. 신뢰성을 확인하기 위해 헤더에 많은 정보를 붙여 검증하므로 속도가 비교적 느리다는 단점이 있습니다.
- **UDP는 비 연결형 프로토콜**입니다. 따라서 3-way handshake 등의 호스트 간 연결 과정이 없고 오류제어, 흐름제어, 혼잡제어 등의 제어 과정이 별도로 없습니다. 따라서 **최소한의 오버헤드**를 가지는 매우 단순한 프로토콜입니다.
- TCP는 신뢰성이 중요한 통신 (HTTP, File 전송) 에 쓰이고 UDP는 실시간성이 더 중요한 통신(스트리밍)에 주로 사용됩니다.

#### TCP의 혼잡 제어(Congestion Control)와 흐름 제어(Flow Control)는 무엇인가요?
#### 왜 HTTP는 TCP를 사용하나요?
#### 어떤 상황에서 UDP를 사용하는 것이 적합한가요?
#### 실시간 비디오 스트리밍이나 온라인 게임에서는 TCP보다 UDP가 선호되는 이유는 무엇일까요? 데이터 손실 가능성은 어떻게 처리하나요?

### ⭐ 그럼 3-way handshake는 무엇이고 각 과정은 어떻게 되나요?
- 3-way handshake는 TCP 프로토콜로 통신하기 전에 상대방 컴퓨터와 세션을 연결하는 과정입니다.
- 먼저 클라이언트 쪽에서 서버 쪽에 **Syn** 패킷을 보내면서 연결을 설정하기를 원한다고 요청을 보냅니다.
- 그 다음, 서버 쪽에서는 이를 수락하면 **Syn 패킷에 ACK 패킷을 담아서** 같이 보내고, 클라이언트 서버에서 **ACK 패킷을 보내** 응답을 하는 과정을 거쳐서 연결을 완료하게 됩니다.

#### 만약 3-way handshake 과정 중 문제가 발생하면 어떻게 되나요?
    
#### 그럼 4-way handshake는 뭔가요?
- 3-way handshake를 통해 연결하고 데이터 전송까지 완료했다면, connection을 끊는 과정을 4-way hand shaking을 통해 이루어집니다.
- 먼저 클라이언트 쪽에서 서버 쪽에 FIn 패킷을 보내서 “연결을 끊겠다” 라는 요청을 보냅니다. 그 다음 서버 쪽에서는 ack 응답을 보내지만, 아직 프로세스가 끝나지 않은 경우에 클라이언트쪽에서 요청을 보낸 것일 수 있으므로, 서버 쪽에서는 프로세스가 종료가 되면 그때 FIN 패킷을 클라이언트 측에 보냅니다.
- 그리고 클라이언트 쪽에서 이에 대한 응답을 ACK 패킷을 서버쪽에 보내면, 비로소 연결이 종료됩니다.
    
### HTTP가 뭔지 설명해 주세요.
    
- HTTP는 HyperText Transfer Protocol의 약자로, **request-response 구조로 웹 상에서 정보를 주고받을 수 있는 프로토**콜입니다. HTTP는 서버 요청 후 응답을 받으면 바로 연결을 끊어버리는 **Connectionless** 특성을 가지고, 이로 인해 이전 상태를 알 수 없다는 **Stateless** 특성을 가지고 있습니다.
    
#### 왜 HTTP는 stateless 구조를 채택하고 있을까요?
    
- stateless는 이전의 상태를 기억하고있지 않는 것을 의미하는데, 서버는 1대의 클라이언트만 통신하는 것이 아니므로 상태를 계속 저장해야한다면 상태를 공유하기 위한 비용이 높아지게 되기 때문입니다.

#### HTTP의 stateless 속성은 어떻게 극복하나요?

### ⭐쿠키와 세션의 차이점을 설명해 주세요
    
- 쿠키는 **클라이언트 로컬**에 key-value 쌍으로 저장되는 데이터 파일이고, 세션은 **서버**에 저장되는 데이터 파일입니다.
- 쿠키는 유효시간 내에서는 클라이언트가 종료되어도 값이 남아서 유지가 되고, 세션은 서버에 저장되기 때문에 클라이언트가 종료됨과 동시에 이전 세션을 참조할 수 없고 서버 자체에서도 일정 시간이 지나면 삭제할 수 있는 기능이 있어서 세션이 쿠키에 비해 보안이 더 좋다는 장점이 있습니다.
    
#### 세션이 보안도 좋은데 쿠키를 사용하는 이유는 뭔가요?
- 세션은 서버에 데이터를 저장하는 것이기 때문에, 많은 데이터가 저장이 되면 서버에 과부하가 걸려서 서버가 느려질 수 있기때문에 쿠키를 사용합니다.
    
#### 쿠키의 사용 예를 아는대로 말씀해주세요
- 1. 팝업을 띄울 때 “ 오늘 다시 보지 않음 “ 체크 시 다시 띄우지 않도록 하는 기능
- 2. 앱에 들어갈 때마다 매번 로그인을 하지 않도록 하는 자동로그인
- 3. 비회원인 상태에서 장바구니
    
#### ⭐⭐ HTTP request method 중 GET vs POST를 비교 설명해 주세요.
    
- GET은 서버에 리소스 조회를 하기 위해서 요청하는 메소드이고, POST는 데이터 처리를 서버에 요청하는 메소드입니다.
- 차이점은 GET은 특정 필요한 정보가 있을 때 queryString으로 API URL 뒤에 붙여서 요청함으로써 리소스를 조회하게 되지만, POST는 Body값에 데이터를 담아 보냄으로써 해당 데이터를 서버가 처리하도록 요청하게 됩니다.
- GET은 Query String까지 포함해서 브라우저 히스토리에 남아서 캐싱이 가능하지만, POST는 Body에 담아서 보내기 때문에 브라우저 히스토리에 남지도 않고, 캐싱도 불가능합니다.
    
#### HTTP request method중 Put vs Patch을 비교 설명해주세요.

- Put과 PATCH는 모두 리소스를 수정하는 메소드인데 PUT은 전체를 수정하는것이고, 만약 해당 리소스가 없다면 새로 생성하게됩니다. PATCH는 리소스의 일부를 수정하는 메소드입니다.
    
### HTTP status code에 대해서 설명해 주세요
    
- 서버에서 클라이언트 요청에 대한 응답을 보내는 응답 코드로, 이 코드를 통해 성공/실패 여부를 판단할 수 있습니다. 
    
#### 알고 있는 status code가 있으신가요? 있다면 설명해주세요.
    
  - **100번대부터 500번대까지**로 구분되어 나옵니다.
  - 100번대는 서버가 클라이언트의 요청을 처리하고 있다는 의미이며
  - 200와 201은 리소스 조회나 생성의 요청이 성공했다는 뜻입니다.
  - 300번대는 리다이렉션되어 클라이언트가 새로운 작업을 추가적으로 진행해야한다는 의미입니다.
  - 400번대는 클라이언트의 오류로, 클라이언트의 요청이 올바르지 않을 때 사용합니다. 특히 400은 클라이언트가 잘못된 요청을 보냈을 때, 401은 클라이언트가 인증을 실패했을 때, 403은 클라이언트가 리소스에 대한 접근 권한이 없을때, 404은 클라이언트가 처리한 요청을 서버가 찾을 수 없을때 사용합니다.
  - 500번대는 서버의 오류로, 서버가 클라이언트의 요청을 처리하지 못할 때 사용됩니다.
    
#### 401 (Unauthorized) 와 403 (Forbidden)은 의미적으로 어떤 차이가 있나요?
    
- 401은 사용자의 인증이 정상적으로 수행되지 않았음을 의미하며, 403은 클라이언트가 리소스에 대한 접근 권한이 없다는 의미입니다.  

#### 200 (ok) 와 201 (created) 의 차이에 대해 설명해 주세요.

- 200은 리소스 조회에 성공했다는 뜻이고, 201은 리소스 생성에 성공했다는 의미입니다.
    
### ⭐⭐ www.google.com을 주소창에 쳤을 때 화면이 나오기까지의 과정을 네트워크 관점으로 설명해 주세요.
    
- google.com을 주소창에 치면 → DNS에 도메인 주소를 요청해서 IP 주소를 찾습니다. → 그리고 IP 주소와 HTTP 요청메시지를 전송 계층에 보내면 → 전송 계층은 HTTP 요청을 위한 HTTP 메시지에 **헤더를 붙여** TCP/IP 프로토콜을 생성하여 이를 구글 서버에 보냅니다.
- 구글 서버가 TCP/IP 패킷을 받게 되면, 언패킹을 통해 헤더를 벗겨냄으로써 HTTP 메시지를 복원하게되어 서버 컴퓨터에 보냅니다. 이 때 HTTP 메시지 요청에 의해 수행한 결과를 HTTP response 메시지로 만들어서, 클라이언트로 보내게 되면 아까 클라이언트가 서버에 보낼 때와 마찬가지로 헤더를 붙여서 클라이언트에 보내면, 클라이언트가 받아서 헤더를 벗겨내서 HTTP 메시지로 복원을 시켜서 해당 응답값을 토대로 렌더링을 하게되어 브라우저 상에 보여지게 됩니다.
    
### DNS에 대해 설명해주세요.
    
- Domain Name System의 줄임말로써 도메인명과 IP 주소를 매칭시킬 때 사용하는 시스템입니다. 따라서 브라우저에 도메인을 치면 맨 먼저 DNS 서버에 요청하여 도메인에 매칭하는 IP 주소를 찾아야합니다.


### ⭐ HTTPS 는 무엇인가요
    
    https://jaeseongdev.github.io/development/2021/07/02/HTTPS,SSL,TLS/
    
    1. HTTPS란?
    - HTTP에 Secure 라는 말이 추가된 말로, 보안이 강화된 HTTP이다.
    2. HTTPS란 SSL, TLS 전송 기술을 사용함
    3. 대칭키 암호 알고리즘 : 키 하나로 데이터를 암호화하고, 암호화된 값을 다시 암호화했던 키로 복호화하는 방식
    4. 공개키 암호 알고리즘 : 공개키, 개인키 서로 다른 2개의 키를 한 쌍으로 암호화/복호화할 때 사용하는 알고리즘. 일반적으로는 공개키로 암호화하고, 개인키로 복호화를 하는데 만약에 서로 쌍이 다른 키로 암호화하거나 복호화할 경우에는 암호화/복호화가 불가능함
    
#### 대칭키 암호 알고리즘이 무엇인가요?
    
- 키 하나로 데이터를 암호화하고, 암호화된 값을 다시 암호화했던 키로 복호화하는 방식
    
#### 공개키 암호 알고리즘이 무엇인가요?
    
- 공개키, 개인키 서로 다른 2개의 키를 한 쌍으로 암호화/복호화할 때 사용하는 알고리즘. 일반적으로는 공개키로 암호화하고, 개인키로 복호화를 하는데 만약에 서로 쌍이 다른 키로 암호화하거나 복호화할 경우에는 암호화/복호화가 불가능함

#### SSL과 TLS의 차이는 무엇인가요?
    
- SSL이 90년대 중반이 생성되어서 TLS보다 더 오래된 프로토콜이고, 지금은 폐지된 프로토콜입니다. TLS은 SSL 이후에 보안을 더 강화한 새로운 프로토콜입니다.

#### 브라우저나 앱이 서버의 SSL/TLS 인증서가 유효한지 어떻게 확인할 수 있나요? (CA, 인증서 체인 개념)

### jwt를 이용한 로그인 방식을 설명해주세요.

1. 사용자가 id와 비밀번호를 입력하여 서버에 로그인 요청을 보냅니다.
2. 해당 로그인 정보가 유효할 경우, 서버는 클라이언트에게 jwt 토큰을 보내줍니다.
3. 클라이언트는 서버에 요청할 때마다 해당 토큰을 authorization 헤더에 담아서 보냄으로써 인증하게 됩니다.
4. 서버는 클라이언트가 jwt 토큰을 보낼 때마다 유효성을 검증하고, 유효할 경우에만 서버를 처리하게 됩니다.

### OAuth를 이용한 로그인 방식을 설명해주세요.

 1. 사용자가 Oauth 제공자를 통해 로그인 요청
 2. Oauth 제공자로부터 권한을 인증받으면, 


### ⭐⭐ Restful API에 대해 설명해 주세요.
    
 https://gmlwjd9405.github.io/2018/09/21/rest-and-restful.html
 
 - Rest API : REST 기반으로 API를 구현한 것을 Rest API 라고 함
 - Restful하다라는 의미는 Rest가 Rest답다? 라는 의미임 
 → 그럼 REST가 뭔데? : Representational State Transfer의 약자로, 자원으로 명칭을 하고 자원 단위로 상태를 표현 및 정보를 주고받는 모든 것을 의미함
 - Rest API의 설계 규칙 중 대표적으로는 URL은 명사를 사용하고, 소문자로 사용하며 슬래시 단위로 계층 관게를 표현합니다. 또한 행위는 HTTP Method(GET, POST, PATCH, PUT 등)과 로써 표현합니다.
    
#### Restful하다는 말의 뜻이 뭔가요?
 - REST API의 설계 의도를 명확하게 지킴으로써, URL만 보더라도 어떤 리소스에 해당되고 Method를 통해 어떤 역할을 하는지 명확하게 설계가 되어있다 라는 의미입니다.

#### RESTful한 특성을 왜 갖춰야 할까요? 무슨 장점이 있는건가요.

 - HTTP 프로토콜 인프라를 그대로 활용하므로 API를 사용함에 있어서 별도의 인프라를 구축할 필요가 없습니다.
 -또한 HTTP 프로토콜의 표준을 최대한 활용하기에, API의 의도가 명확하여 개발자 간에 정해진 의미로 커뮤니케이션할 수 있습니다.
    
#### 그럼 모든 웹 API들을 RESTful하게 만들면 좋겠네요?
    
 - 아직 구형 브라우저는 PUT, DELETE가 제대로 지원하지 않는 브라우저들이 있어서 모든 웹 API들을 Restful하게 만들기에는 무리가 있습니다.
 - 그리고 아직 REST API의 정해진 표준은 없기때문에 모든 웹을 Restful을 도입하기에 무리가 있다고 생각합니다.
 
#### REST의 제약 조건(Stateless, Cacheable, Client-Server 등)에 대해 설명해주세요.
